## 算法分析

算法是为了求解问题所遵循的，被清晰地指定的单元指令的集合。



通常，对于一个给定的算法，我们要做 两项分析。**第一是从数学上证明算法的正确性**，这一步主要用到形式化证明的方法及相关推理模式，如循环不变式、数学归纳法等。而在证明算法是正确的基础上，**第二部就是分析算法的时间复杂度**。算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好反映出算法的优劣与否。如果一个算法执行时间过长，那么是没有意义的。

一个用高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素

  - (1). 算法采用的策略、方法；
  - (2). 编译产生的代码质量；
  - (3). 问题的输入规模；
  - (4).  机器执行指令的速度。
  
  一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的，则算法时间取决于两者的综合效果。为了便于比较同一个问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作的重复执行的次数作为算法的时间量度。


### 时间复杂度

 - （1）时间频度 一个算法执行所耗费的时间。从理论上是不能算出来的，必须上机运行测试才能知道。**一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)**

- （2）时间复杂度 在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

 > T (n) = Ο(f (n)) 表示存在一个常数C，使得在当n趋于正无穷时总有 T (n) ≤ C * f(n)。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。也就是说当n趋于正无穷时T (n)的上界是C * f(n)。其虽然对f(n)没有规定，但是一般都是取尽可能简单的函数。例如，O(2n^2+n +1) = O (3n^ss2+n+3) = O (7n^2 + n) = O ( n^2 ) ，一般都只用O(n2)表示就可以了。注意到大O符号里隐藏着一个常数C，所以f(n)里一般不加系数。如果把T(n)当做一棵树，那么O(f(n))所表达的就是树干，只关心其中的主干，其他的细枝末节全都抛弃不管。
  
   在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),...， k次方阶O(nk),指数阶O(2n)
   
  常见的算法时间复杂度由小到大依次为：
  ```
  Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)
  ```
  
  （3）求解算法的时间复杂度的具体步骤是
  
   
- ⑴ 找出算法中的基本语句；
　　算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。
　　
　
- ⑵ 计算基本语句的执行次数的数量级；
只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。

　　
- ⑶ 用大Ο记号表示算法的时间性能。
将基本语句执行次数的数量级放入大Ο记号中。
如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加

　第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，则整个算法的时间复杂度为Ο(n+n2)=Ο(n2)。

```
# O(n)
for (i=1; i<=n; i++)  
       x++;  
       
# O(n^2)
for (i=1; i<=n; i++)  
    　for (j=1; j<=n; j++)  
          x++;  
```






> Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n^2)和Ο(n^3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为P（Polynomial,多项式）类问题，而把后者（即指数时间复杂度的算法）称为NP（Non-Deterministic Polynomial, 非确定多项式）问题

- （4）在计算算法时间复杂度时有以下几个简单的程序分析法则:
    - (1).对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间
    - (2).对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下"求和法则"
求和法则:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n)))
特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n))
    - (3).对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间
    - (4).对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下"乘法法则"
乘法法则: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1*T2=O(f(n)*g(n))
    - (5).对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度
另外还有以下2个运算法则 ：\(1) 若g(n)=O(f(n)),则O(f(n))+ O(g(n))= O(f(n))；(2) O(Cf(n)) = O(f(n)),其中C是一个正常数


下面分别对几个常见的时间复杂度进行示例说明：

**(1)、O(1)**

```
  Temp=i; i=j; j=temp;     
  
```
以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。注意：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。

**（2）、 O(n2) **
```
sum=0；                 （一次）  
for(i=1;i<=n;i++)     （n+1次）  
   for(j=1;j<=n;j++) （n^2次）  
    sum++；            （n^2次）  
    
```
解：因为Θ(2n^2+n+1)=n2（Θ即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以T(n)= =O(n2)；

**(3)、O(n)**

```
a=0;   //1
  b=1;    //1                  
  for (i=1;i<=n;i++) // n
  {    
     s=a+b;　　　　  // n-1
     b=a;　　　　　// n-1
     a=s;　　　　　// n-1
  }  
```

 T(n)=2+n+3(n-1)=4n-1=O(n).
 

**(4)、O(log2n)**

```

i=1;     // 1
while (i<=n)  
  i=i*2; ② 
  
```

 设语句2的频度是f(n),   则：2^f(n)<=n;f(n)<=log2n取最大值f(n)=log2n,
T(n)=O(log2n )


**(5)、O(n3)**

```

for(i=0;i<n;i++)  
   {    
      for(j=0;j<i;j++)    
      {  
         for(k=0;k<j;k++)  
            x=x+2;    
      }  
   }
   
```

常见时间复杂度



排序法 | 最差时间分 | 平均时间复杂度 |稳定度|空间复杂度|
---|------|------|------|---|
冒泡排序法 | O(n2) | O(n2) |稳定| O(1)
快速排序   | O(n2) | O(n*log2n) |不稳定| O(log2n)~O(n)
选择排序   | O(n2) | O(n2) |稳定| O(1)
二叉树排序 | O(n2) | O(n*log2n)) |不稳定| 	O(n)
插入排序法 | O(n2) | O(n2) |稳定| O(1)
堆排序     | O(n*log2n) | O(n*log2n) |不稳定定| O(1)


一个经验规则：其中c是一个常量，如果一个算法的复杂度为c 、 log2n 、n 、 n*log2n ,那么这个算法时间效率比较高 ，如果是2^n ,3^n ,n!，那么稍微大一些的n就会令这个算法不能动了，居于中间的几个则差强人意。


### 算法的空间复杂度

个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。

如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。