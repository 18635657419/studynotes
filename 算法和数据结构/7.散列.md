## 散列

散列又叫hash。是通过关键字把数据映射到指定位置的一种数据结构。理想的散列表，是一个包含关键字的固定大小的数组

 哈希表存储的是键值对，其查找的时间复杂度与元素数量多少无关，哈希表在查找元素时是通过计算哈希码值来定位元素的位置从而直接访问元素的，因此，哈希表查找的时间复杂度为O（1）。

array | 
---|---
key 1 |
key 2 | 


### 散列函数

hash(key) 通过一个散列的函数，将关键字进行计算，将计算的结果存到表里。如果关键字是一个整数，那么只要mod表长。如果关键字是一个字符串。通常的做法是将字符串转成ascii.然后再通过hash函数计算。 常见的哈希函数


1. 直接寻址法

取关键字或者关键字的某个线性函数值作为哈希地址,即H(Key)=Key或者H(Key)=a*Key+b(a,b为整数),这种散列函数也叫做自身函数.如果H(Key)的哈希地址上已经有值了,那么就往下一个位置找,知道找到H(Key)的位置没有值了就把元素放进去.

2.   数字分析法

分析一组数据,比如一组员工的出生年月,这时我们发现出生年月的前几位数字一般都相同,因此,出现冲突的概率就会很大,但是我们发现年月日的后几位表示月份和具体日期的数字差别很大,如果利用后面的几位数字来构造散列地址,则冲突的几率则会明显降低.因此数字分析法就是找出数字的规律,尽可能利用这些数据来构造冲突几率较低的散列地址.

3.   平方取中法

取关键字平方后的中间几位作为散列地址.一个数的平方值的中间几位和数的每一位都有关。因此，有平方取中法得到的哈希地址同关键字的每一位都有关，是的哈希地址具有较好的分散性。该方法适用于关键字中的每一位取值都不够分散或者较分散的位数小于哈希地址所需要的位数的情况。

4.   折叠法

折叠法即将关键字分割成位数相同的几部分,最后一部分位数可以不同,然后取这几部分的叠加和(注意:叠加和时去除进位)作为散列地址.数位叠加可以有移位叠加和间界叠加两种方法.移位叠加是将分割后的每一部分的最低位对齐,然后相加;间界叠加是从一端向另一端沿分割界来回折叠,然后对齐相加.

5.   随机数法

选择一个随机数,去关键字的随机值作为散列地址,通常用于关键字长度不同的场合.

6.   除留余数法

取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址.即H(Key)=Key MOD p,p<=m.不仅可以对关键字直接取模,也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选得不好，则很容易产生冲突。一般p取值为表的长度tableSize。

一个简单的hash函数

```
int hash(char *key,int size){
    
    int temp = 0;
    
    while(*key != '\0') {
        
        temp += *key++;
    }
    
    return temp%size;
    
    
}


```


### 散列冲突

当使用hash函数计算的时候。可能会出现冲突。即通过hash函数计算得到的结果是一样的。举个例子


```

int hash(int key,int size) {
    
    return key%size;
}

hash(20,10);

hash(30,10);

会冲突

```


#### 1.分离链接法

解决hash冲突的第一种方法就是分离链接法。简单的说就是拉链表。将冲突的元素放到该链表的后面。我们通过查找的时候，查到在对应的hashtable中。然后再遍历链表就能找到该元素。

![image](http://img.blog.csdn.net/20160418101347575?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



#### 3.开放定址法

分离链接的算法的缺点需要指针，给新单元分配地址空间需要时间。导致了算法的缓慢，另外一种解法也是通过链表的方法来实现的。叫开放定址法。在开放定址的方法中，如果有冲突发生，就尝试其他的单元。


- 线性探测

如果h(k)被占用，就按照如下序列探测：(h(k)+p(1))%TSize,(h(k)+p(2))%TSize,...,(h(k)+p(i))%TSize,... 

其中，h(k)为哈希函数，TSize为哈希表的长度，p(i)为探测函数。在(h(k)+p(i))%TSize的基础上，若发现冲突，则使用 
增量p(i+1)进行新的探测，直到无冲突为止。 

其中，根据探测函数p(i)的不同，开发地址发又分为： 

线性探测法（p(i)=i:1,2,3,4,5,6,....）;    

二次（或平方）探测法：（p(i)=((-1)^(i-1))(i)^2:1,-1,4,-4,9,-9,......） 

随机探测法（p(i):为随机数） 

双散列函数（双散列函数h(key)、hp(key)，如果h(key)出现冲突，则再使用hp(key)求取散列地址） 

探测序列为：h(k),h(k)+hp(k), ... ,h(k)+i*hp(k),... 

-  二次探测

二次探测是过程是x+1,x+4,x+9,以此类推。二次探测的步数是原始位置相隔的步数的平方。

![image](http://img.blog.csdn.net/20161008171155342)
hash表中的数据项和表长的比例叫做装填因子


- 再哈希法


再哈希是把关键字用不同的哈希函数再做一遍哈希化，用这个结果作为步长，对指定的关键字，探测的步长是不变的，可以说不同的关键字可以使用不同的步长，并且步长可以控制。一般来说，再哈希函数可以采用以下这种：

        stepSize=constant-(key%constant);


虽然不同的关键字可能会映射到相同的数组单元，但是可能会有不一样的探测步长。假设可以使用步长1~5进行探测。步长是不能为零的，不然就会形成死循环。再哈希的实现方式可以在线性探测的基础上添加一个再哈希函数即可，对应在delete和find方法里面修改相关操作。