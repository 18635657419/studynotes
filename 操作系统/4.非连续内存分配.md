## 非连续物理内存

物理地址不是非连续的，更好的内存利用和管理，允许共享代码和数据

管理开销比较大。

### 分段

分段更好的分离和管理。分段、段偏移

分段的逻辑 将逻辑地址映射成物理地址。

分段寻址方案：

段号、段地址。

一个段：一个内存块。

程序访问内存地址需要一个二维数组。

段表：操作系统建立



**分段地址结构**

作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例程序段、数据段等。每个段都从0开始编址，并采用一段连续的地址空间。

段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间是二维的。

15           12   11                  0

       段号            段内位移量

段号4位，每个作业最多24=16段，表示段号从0000~1111（24-1）；段内位移量12位，212=4k，表示每段的段内地址最大为4K（各段长度不同），从000000000000~111111111111

**4. 段表**

段号 段长 起始地址 存取控制   

0     1K     4096    

1     4K     17500    

2     2K     8192  

### 分页

分页地址空间、页地址方案

页帧的大小是固定的。

划分物理内存至固定的frame

化为逻辑地址空间至相同大小的页（page）

将物理地址转成逻辑地址。



页帧号、页帧偏移。

一个内存物理地址是一个二元组（F，O）

F是一帧号，F位 共有2^F个 zhen。

o一帧内偏移（s位，每帧有2^sz字节）

物理地址 = 2^s+o



页

一个程序的逻辑地址空间被划分为大小相同的页

### 页表

**页表**

分页系统中，允许将进程的每一页离散地存储在内存的任一物理块中，为了能在内存中找到每个页面对应的物理块，系统为每个进程建立一张页面映射表，简称页表。页表的作用是实现从页号到物理块号的地址映射。

页表：

页号 物理块号 存取控制   

  0        2    

  1       15（F）    

  2       14（E）    

  3       1  

页表就是一个大数组。

![img](http://7xk3em.com1.z0.glb.clouddn.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F02.jpg)

页表可能会比较大。



### 多级页表

类似树结构。

### 反向页表

不让页表和逻辑地址空间的大小对应。而是让页表和物理地址的大小向对应。



# 分段和分页内存管理

**两者描述**

        打个比方，比如说你去听课，带了一个纸质笔记本做笔记。笔记本有100张纸，课程有语文、数学、英语三门，对于这个笔记本的使用，为了便于以后复习方便，你可以有两种选择。

         第一种是，你从本子的第一张纸开始用，并且事先在本子上做划分：第2张到第30张纸记语文笔记，第31到60张纸记数学笔记，第61到100张纸记英语笔记，最后在第一张纸做个列表，记录着三门笔记各自的范围。这就是分段管理，第一张纸叫段表。 

         第二种是，你从第二张纸开始做笔记，各种课的笔记是连在一起的：第2张纸是数学，第3张是语文，第4张英语……最后呢，你在第一张纸做了一个目录，记录着语文笔记在第3、7、14、15张纸……，数学笔记在第2、6、8、9、11……，英语笔记在第4、5、12……。这就是分页管理，第一张纸叫页表。你要复习哪一门课，就到页表里查寻相关的纸的编号，然后翻到那一页去复习

        **两者的优缺点：**

        在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）

        在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）

        **两者的不同点：**

(1) 分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。

(2) 页的大小固定且由系统决定，由系统把[逻辑地址](http://baike.baidu.com/view/893778.htm)划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定，决定于用户所编写的程序，通常由[编译程序](http://baike.baidu.com/view/454895.htm)在对[源程序](http://baike.baidu.com/view/546605.htm)进行编译时，根据信息的性质来划分。

(3) 分页的作业[地址空间](http://baike.baidu.com/view/1507129.htm)是一维的，即单一的[线性地址](http://baike.baidu.com/view/2690747.htm)空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。

**两者结合——段页式存储管理：**

1．基本思想：

分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形成了段页式存储管理方式。

在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。

段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量

程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。

为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。

**2．地址变换的过程：**

（1）程序执行时，从PCB中取出段表始址和段表长度，装入段表寄存器。

（2）由地址变换机构将逻辑地址自动分成段号、页号和页内地址。

（3）将段号与段表长度进行比较，若段号大于或等于段表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。

（4）将段表始址与段号和段表项长度的乘积相加，便得到该段表项在段表中的位置。

（5）取出段描述子得到该段的页表始址和页表长度。

（6）将页号与页表长度进行比较，若页号大于或等于页表长度，则表示本次访问的地址已超越进程的地址空间，产生越界中断。

（7）将页表始址与页号和页表项长度的乘积相加，便得到该页表项在页表中的位置。

（8）取出页描述子得到该页的物理块号。

（9）对该页的存取控制进行检查。

（10）将物理块号送入物理地址寄存器中，再将有效地址寄存器中的页内地址直接送入物理地址寄存器的块内地址字段中，拼接得到实际的物理地址。