## 操作启动

硬盘存放操作系统。BIOS基本IO处理系统。自检。

bootloader 加载操作系统。放在硬盘的第一个主引导扇区(512字节)。

BIOS 从特定的地址开始执行。从段寄存器、ip指定寄存器开始执行。

1. POST自检（加电自检）。寻找显卡和Bios 
2. bootload 把操作系统的代码和数据加载到内存，跳转到操作系统的起始位置。



## 操作系统交互

系统调用：应用程序向操作系统发出服务请求。（来源应用程序）

异常：非法的指令，（来源不良的应用程序）

中断：（来源外设）

在操作系统中，内核被信任的第三方。只有内核执行第三方的指令。屏蔽底层的复杂性。



处理时间：

- 中断：异步事件
- 异常：同步
- 系统调用：异步或同步

响应状态

- 中断：持续 对用户应用程序是透明的
- 异常：杀死异常的程序。重试
- 系统调用：等待和持续（等待服务完成）



硬件 设置中断标记（），将内部、外部事件设置中断标记，记录中断id。

操作系统需要保存被打乱的状态保持。中断服务，清除中断标记。

中断 设置中断表。

设置中断标记



异常（比如 /0 操作）

- 保存现场
- 异常处理 杀死程序。或重新执行指令
- 恢复现场





系统调用（系统系统调用接口）

比如应用程序调用printf。会触发系统调用write系统。访问对应的设备io。

- win32 api 用于windows
- POSIX API 

通常情况下。与每个系统调用相关的序号。

application->库->系统调用

系统调用和函数调用。

函数调用在一个栈的空间内完成了数据的返回。

系统调用：切换堆栈，内核态和用户态切换。系统开销大。



系统调用的开销

在执行时间上的开销超过程序调用。

建立中断、异常、系统调用号与对应服务

建立内核堆栈。不能为用户的堆栈混淆。

内核态映射到用户态的地址空间

内核态独立地址空间。