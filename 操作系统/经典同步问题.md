### 读写问题

多个并发进程的数据集共享

- 读者 只读数据集 他们不执行任何更新
- 写者，可以读取和写入

共享数据

- 数据集
- 信号量countmutex 初始化1
- 信号量writemutex初始化为1



至于谁优先的问题，主要从以下两个方面来判断：

​        1、当优先级低的进程获得临界区时，高优先级进程能从低优先级进程中抢得临界区的访问权

​        2、当优先级高的进程在访问临界区时，低优先级进程必须等待，直到高优先级全部访问完才有机会访问临界区

可以将所有读者和所有写者分别存于一个读者等待队列和一个写者等待队列中，每当读允许时，就从读者队列中释放一个或多个读者线程进行读操作；
当写允许时，就从写者队列中释放一个写者线程进行写操作。
　　读者优先。读者优先指的是除非有写者在写文件，否则读者不需要等待。所以可以用一个整数变量Read_count记录当前的读者数目，用于确定是否需要释放正在等待的写者进程（当Read_count=0时，表明所有的读者读完，需要释放写者等待队列中的一个写者）。每当一个读者开始读文件时，必须修改Read_count变量。因此需要一个互斥对象mutex来实现对全局变量Read_count修改时的互斥。
　　另外，为了实现读-写互斥，需要增加一个临界区对象Write。当写者发出写请求时，必须申请临界区对象的所有权。通过这种方法，可以实现读-写互斥，当Read_count=1时（即第一个读者到来时），读者线程也必须申请临界区对象的所有权。
　　当读者拥有临界区的所有权时，写者阻塞在临界区对象Write上。当写者拥有临界区的所有权时，第一个读者判断完”Read_count==1”后阻塞在Write上，其余的读者由于等待对Read_count的判断，阻塞在mutex上。
　　写者优先。写者优先与读者优先相类似。不同之处在于一旦一个写者到来，它应该尽快对文件进行写操作，如果有一个写者在等待，则新到来的读者不允许进行读操作。为此应当填加一个整形变量Write_count，用于记录正在等待的写者的数目，当Write_count=0时，才可以释放等待的读者线程队列